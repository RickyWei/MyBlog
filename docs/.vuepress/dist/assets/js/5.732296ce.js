(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{372:function(e,t,a){e.exports=a.p+"assets/img/udpheader.740fa2a7.jpg"},373:function(e,t,a){e.exports=a.p+"assets/img/tcpheader.719c8aba.jpg"},374:function(e,t,a){e.exports=a.p+"assets/img/tcphandshake.c9d5bcf7.jpg"},375:function(e,t,a){e.exports=a.p+"assets/img/tcphandwave.bc8c7ee2.jpg"},376:function(e,t,a){e.exports=a.p+"assets/img/fastretransimission.cf7226c4.jpg"},377:function(e,t,a){e.exports=a.p+"assets/img/swnd.1265dd38.jpg"},378:function(e,t,a){e.exports=a.p+"assets/img/rwnd.45339d1f.jpg"},379:function(e,t,a){e.exports=a.p+"assets/img/congestioncontrol.b0741616.png"},426:function(e,t,a){"use strict";a.r(t);var s=a(25),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"transport-layer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#transport-layer"}},[e._v("#")]),e._v(" Transport Layer")]),e._v(" "),s("h2",{attrs:{id:"udp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[e._v("#")]),e._v(" UDP")]),e._v(" "),s("h3",{attrs:{id:"udp-header"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#udp-header"}},[e._v("#")]),e._v(" UDP header")]),e._v(" "),s("p",[s("img",{attrs:{src:a(372),alt:"UDP header"}})]),e._v(" "),s("h2",{attrs:{id:"tcp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[e._v("#")]),e._v(" TCP")]),e._v(" "),s("h3",{attrs:{id:"tcp-header"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-header"}},[e._v("#")]),e._v(" TCP header")]),e._v(" "),s("p",[s("img",{attrs:{src:a(373),alt:"TCP header"}})]),e._v(" "),s("h3",{attrs:{id:"tcp-3-handshake"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-3-handshake"}},[e._v("#")]),e._v(" TCP 3-handshake")]),e._v(" "),s("p",[s("img",{attrs:{src:a(374),alt:"TCP handshake"}})]),e._v(" "),s("ol",[s("li",[e._v("ISN(Initial Sequence Number) is select randomly")]),e._v(" "),s("li",[e._v("3 times handshake is a kind of protect for server side.\nIn the case that client has sent SYN but get server's ACK and\nSYN late(timeout), client thinks the server does not response\nbut server thinks handshake has completed and wait idlely.")])]),e._v(" "),s("h3",{attrs:{id:"tcp-4-handwave"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-4-handwave"}},[e._v("#")]),e._v(" TCP 4-handwave")]),e._v(" "),s("p",[s("img",{attrs:{src:a(375),alt:"tcp 4 handwave"}})]),e._v(" "),s("ol",[s("li",[e._v("TCP is duplex, it allows each of direction closed undependly")]),e._v(" "),s("li",[e._v("There is a 2MSL(Max Segment Lifetime) time wait after active opener\n"),s("ol",[s("li",[e._v("To response passive opener's FIN and ACK, which allow server to re-send FIN if lost")]),e._v(" "),s("li",[e._v("To get rid of old message delivered to new session which has same IP and port number")])])])]),e._v(" "),s("h3",{attrs:{id:"tcp-reliability"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-reliability"}},[e._v("#")]),e._v(" TCP Reliability")]),e._v(" "),s("h4",{attrs:{id:"time-based-retransimission"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#time-based-retransimission"}},[e._v("#")]),e._v(" time based Retransimission")]),e._v(" "),s("ol",[s("li",[e._v("TCP RTO(Retransmission Timeout)based on RTT(Round Trip Time)")]),e._v(" "),s("li",[e._v("TCP has a timer and retransimit after exceeding RTO")]),e._v(" "),s("li",[e._v("Classic Method\n"),s("ol",[s("li",[e._v("$SRTT\\leftarrow \\alpha (SRTT)+(1-\\alpha) RTT_{s}\\qquad \\alpha\\in[0.8,0.9]$")]),e._v(" "),s("li",[e._v("$RTO=\\min(ubound,\\max(lbound,(SRTT)\\beta))\\qquad \\beta\\in[1.3,2.0],ubound=1min,lbound=1s$")])])]),e._v(" "),s("li",[e._v("Standard Method\n"),s("ol",[s("li",[e._v("$srtt\\leftarrow (1-g)(srtt)+(g)M\\qquad M=\\text{mean deviation}$")]),e._v(" "),s("li",[e._v("$rttvar\\leftarrow (1-h)(rttvar)+(h)(|M-srtt|)$")]),e._v(" "),s("li",[e._v("$RTO=srtt+4(rttvar)$")])])])]),e._v(" "),s("h4",{attrs:{id:"fast-retransimission"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fast-retransimission"}},[e._v("#")]),e._v(" Fast Retransimission")]),e._v(" "),s("p",[s("img",{attrs:{src:a(376),alt:"fast retransmission"}})]),e._v(" "),s("ol",[s("li",[e._v("TCP reveiver sends ACK immeadately when received out of order segment")]),e._v(" "),s("li",[e._v("When TCP server reveived duplicate ACK, it judges if these ACK caused by segemnt loss or network delay according to duplicate ACK threshold")]),e._v(" "),s("li",[e._v("Fast Retransimission does not need to wait RTO")])]),e._v(" "),s("h3",{attrs:{id:"tcp-flow-control"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-flow-control"}},[e._v("#")]),e._v(" TCP Flow Control")]),e._v(" "),s("h4",{attrs:{id:"delary-ack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#delary-ack"}},[e._v("#")]),e._v(" Delary ACK")]),e._v(" "),s("ol",[s("li",[e._v("Wait a little time to send ACK when received a packet")]),e._v(" "),s("li",[e._v("Try to put ACK to the packet which will be sent to peer side")])]),e._v(" "),s("h4",{attrs:{id:"nagle-algorithm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nagle-algorithm"}},[e._v("#")]),e._v(" Nagle Algorithm")]),e._v(" "),s("ol",[s("li",[e._v("Do not send small packet($< SMSS(Sender Maximum Segment Size)$) when does not receive previous ACK")]),e._v(" "),s("li",[e._v("Nagle works as sefl-clocking, the faster ACK comes back, the more data will be sent")]),e._v(" "),s("li",[e._v("Nagle works on a trade-off which use less number packet(with big overload), but increase the delay")])]),e._v(" "),s("h4",{attrs:{id:"slide-window"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#slide-window"}},[e._v("#")]),e._v(" Slide Window")]),e._v(" "),s("p",[s("img",{attrs:{src:a(377),alt:"send window"}}),e._v(" "),s("img",{attrs:{src:a(378),alt:"send window"}})]),e._v(" "),s("ol",[s("li",[e._v("TCP header's windows size filed indicate empty receive buffer space(Bytes)")]),e._v(" "),s("li",[e._v("$\\max SEQ=ACK+\\text{Window Size}$")]),e._v(" "),s("li",[e._v("sender send window probesto query reveiver's free space, which forces recevier response ACK and Winodw Size")]),e._v(" "),s("li",[e._v("SWS(Silly Window Syndrome) phenomenon means only small segment can be transimted\n"),s("ol",[s("li",[e._v("receiver does not advertise small window")]),e._v(" "),s("li",[e._v("sender does not send small segment according to Nagle")])])])]),e._v(" "),s("h3",{attrs:{id:"tcp-congestion-control"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-congestion-control"}},[e._v("#")]),e._v(" TCP Congestion Control")]),e._v(" "),s("p",[s("img",{attrs:{src:a(379),alt:"congestion control"}})]),e._v(" "),s("h4",{attrs:{id:"slow-start"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#slow-start"}},[e._v("#")]),e._v(" Slow Start")]),e._v(" "),s("ol",[s("li",[e._v("Slow start happens when connection established or packet loss")]),e._v(" "),s("li",[e._v("Slow start happens after exchange of SYN and cwnd(Congestion Winodow) = IW(Initial Winodw) = SMSS")]),e._v(" "),s("li",[e._v("If no loss packet，$W=2\\times W_{pre}$")]),e._v(" "),s("li",[e._v("Delay ACK is adopted after slow start since it decrease speed up ration")]),e._v(" "),s("li",[e._v("TCP's send speed is $W/RTT$. cwnd will be decreased to half of previus value when W is too big, this time point is ssthresh(slow start threshold)")])]),e._v(" "),s("h4",{attrs:{id:"congestion-avoidance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#congestion-avoidance"}},[e._v("#")]),e._v(" Congestion Avoidance")]),e._v(" "),s("ol",[s("li",[e._v("After ssthresh，$cwnd_{t+1}=cwnd_{t}+SMSS*SMSS/cwnd_{t}$，cwnd+=about 1 for each time")])]),e._v(" "),s("h4",{attrs:{id:"fast-recovery"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fast-recovery"}},[e._v("#")]),e._v(" Fast Recovery")]),e._v(" "),s("ol",[s("li",[e._v("After fast retransimission，set $ssthresh=\\max(\\text{flight size}/2,2*SMSS)$")]),e._v(" "),s("li",[e._v("After the decreasing, start with new ssthreash rather than $cwnd=1MSS$ with slow start")])]),e._v(" "),s("h3",{attrs:{id:"tcp-seperate-each-packet"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-seperate-each-packet"}},[e._v("#")]),e._v(' TCP seperate each "packet"')]),e._v(" "),s("ol",[s("li",[e._v("TCP is stream protocol, receiver may receive half segment,\none segment or multiple segment at each time")]),e._v(" "),s("li",[e._v("This is caused by\n"),s("ol",[s("li",[e._v("Nagle -> It does not send small packet immeadeatly and try to send many segment together")]),e._v(" "),s("li",[e._v("Recevier can not comsume segment from buffer quickly -> TCP buffer accumulates many segment")])])]),e._v(" "),s("li",[e._v("Can be solved by\n"),s("ol",[s("li",[e._v('Construct a "packet" -> define a packet header which indicate the length of data')])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);