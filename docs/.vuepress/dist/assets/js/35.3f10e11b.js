(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{437:function(a,t,s){"use strict";s.r(t);var _=s(25),v=Object(_.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"动态规划"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[a._v("#")]),a._v(" 动态规划")]),a._v(" "),s("h2",{attrs:{id:"性质"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性质"}},[a._v("#")]),a._v(" 性质")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),s("p",[a._v("动态规划本质还是一种枚举")])]),a._v(" "),s("ol",[s("li",[a._v("最优子结构：全局最优解包含局部最优解")]),a._v(" "),s("li",[a._v("重叠子问题：递归算法反复求解相同的子问题")]),a._v(" "),s("li",[a._v("无后性：即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响")])]),a._v(" "),s("h2",{attrs:{id:"初始化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[a._v("#")]),a._v(" 初始化")]),a._v(" "),s("ol",[s("li",[a._v("dp数组大小：\n"),s("ol",[s("li",[a._v("$维度 = 数据维度 + 隐含维度（与限制条件有关 || ）$")]),a._v(" "),s("li",[a._v("根据状态范围确定，$n+1$通常为了方便计算（返回 $dp[n]$）")])])]),a._v(" "),s("li",[a._v("值：\n"),s("ol",[s("li",[a._v("单个点，相邻点")]),a._v(" "),s("li",[a._v("边界线，对角线")])])])]),a._v(" "),s("h2",{attrs:{id:"状态转移"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态转移"}},[a._v("#")]),a._v(" 状态转移")]),a._v(" "),s("h3",{attrs:{id:"转移方程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#转移方程"}},[a._v("#")]),a._v(" 转移方程")]),a._v(" "),s("ol",[s("li",[a._v("先思考使用回溯的罗杰")]),a._v(" "),s("li",[a._v("确定下标代表的状态含义")])]),a._v(" "),s("h3",{attrs:{id:"记忆化搜索"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#记忆化搜索"}},[a._v("#")]),a._v(" 记忆化搜索")]),a._v(" "),s("ol",[s("li",[a._v("递归时使用空间记录中间子问题结果")]),a._v(" "),s("li",[a._v("需要区分未计算和其他特殊值（无解）")])]),a._v(" "),s("h3",{attrs:{id:"递推"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递推"}},[a._v("#")]),a._v(" 递推")]),a._v(" "),s("ol",[s("li",[a._v("是递归的逆序，从子问题开始求解")]),a._v(" "),s("li",[a._v("循环顺序取决于，按何种顺序是求解小问题（范围）->大问题（范围）")])]),a._v(" "),s("h2",{attrs:{id:"线性dp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线性dp"}},[a._v("#")]),a._v(" 线性DP")]),a._v(" "),s("p",[a._v("$dp[i]=max{dp[i-1]+cost[i]}$")]),a._v(" "),s("h2",{attrs:{id:"区间dp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区间dp"}},[a._v("#")]),a._v(" 区间DP")]),a._v(" "),s("p",[a._v("$dp[i][j]=max{dp[i][k]+dp[k+1][j]+cost[i][j]}$")]),a._v(" "),s("h2",{attrs:{id:"背包模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#背包模型"}},[a._v("#")]),a._v(" 背包模型")]),a._v(" "),s("h3",{attrs:{id:"_01背包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_01背包"}},[a._v("#")]),a._v(" 01背包")]),a._v(" "),s("p",[a._v("有 $n$ 件物品，放入最大容量 $v$ 的背包，第 $i$ 件物品体积（费用）$c[i]$ 价值$w[i]$，求最大价值")]),a._v(" "),s("p",[a._v("$dp[i][j]=max{dp[i-1][j],dp[i][j-c[i]]+w[i]]}\\qquad (c=cost, w=weight)$")]),a._v(" "),s("h3",{attrs:{id:"完全背包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#完全背包"}},[a._v("#")]),a._v(" 完全背包")]),a._v(" "),s("p",[a._v("每种物品个数不限")]),a._v(" "),s("p",[a._v("$dp[i][j]=max{dp[i][j-k"),s("em",[a._v("c[i]]+k")]),a._v("w[i]]}$")]),a._v(" "),s("h3",{attrs:{id:"多重背包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多重背包"}},[a._v("#")]),a._v(" 多重背包")]),a._v(" "),s("p",[a._v("第 $i$ 种物品有 $M_i$ 个")]),a._v(" "),s("p",[a._v("$dp[i][j]=max{dp[i][j-k"),s("em",[a._v("c[i]]+k")]),a._v("w[i]]}$")]),a._v(" "),s("h3",{attrs:{id:"二维费用背包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二维费用背包"}},[a._v("#")]),a._v(" 二维费用背包")]),a._v(" "),s("p",[a._v("每件物品有两种费用")]),a._v(" "),s("p",[a._v("$dp[i][j][k]=max{dp[i-1][j][k],dp[i][j-c_1[i]][k-c_2[i]]+w[i]}$")]),a._v(" "),s("h3",{attrs:{id:"分组背包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分组背包"}},[a._v("#")]),a._v(" 分组背包")]),a._v(" "),s("p",[a._v("物品被划分为 $k$ 组，每组中的物品相互冲突只能选一件")]),a._v(" "),s("p",[a._v("$dp[i][j]=max{dp[i-1][j],dp[i-1][j-c[k]]+w[k]} \\qquad \\text{k in group i}$")]),a._v(" "),s("h3",{attrs:{id:"有依赖背包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有依赖背包"}},[a._v("#")]),a._v(" 有依赖背包")]),a._v(" "),s("p",[a._v("物品 $i$ 依赖于物品 $j$，即选 $i$ 必须选 $j$")]),a._v(" "),s("h3",{attrs:{id:"泛化物品"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#泛化物品"}},[a._v("#")]),a._v(" 泛化物品")]),a._v(" "),s("p",[a._v("泛化物品是一个定义域为 $0\\cdots v$ 的函数 $f$，当分配给费用 $j$ 时，价值为$f(j)$")]),a._v(" "),s("h3",{attrs:{id:"背包问法变化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#背包问法变化"}},[a._v("#")]),a._v(" 背包问法变化")]),a._v(" "),s("h4",{attrs:{id:"输出方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#输出方案"}},[a._v("#")]),a._v(" 输出方案")]),a._v(" "),s("p",[a._v("记录下每个状态的最优解由状态转移方程的哪一项推出\n01背包中，可用 $g[[i][j]=0$ 表示$dp[i][j]=dp[i-1][j]$ ， $g[i][j]=1$ 表示 $dp[i][j]=dp[i-1][j-c[i]]+w[i]$")]),a._v(" "),s("h4",{attrs:{id:"输出字典序最小最优方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#输出字典序最小最优方案"}},[a._v("#")]),a._v(" 输出字典序最小最优方案")]),a._v(" "),s("p",[a._v("可先把物品编号做 $x\\leftarrow N+1-x$ 的转换，在输出方案时转换回来，编号变换后可按之前的转移方程求值，\n输出方案时，如果 $dp[i-1][j]$ 和 $dp[i-1][j-c[i]]+w[i]$ 都成立，按照后者输出，即选择了物品 $i$ 输出其原来的编号 $N-1-i$")]),a._v(" "),s("h4",{attrs:{id:"方案总数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方案总数"}},[a._v("#")]),a._v(" 方案总数")]),a._v(" "),s("p",[a._v("如求装满背包时方案的总数\n在初始化时 $dp[0][0]=0\\qquad dp[0][1\\cdots v]$，将 $\\max$ 改为 $sum$")]),a._v(" "),s("h4",{attrs:{id:"最优方案总数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最优方案总数"}},[a._v("#")]),a._v(" 最优方案总数")]),a._v(" "),s("p",[a._v("$dp[i][j]$ 表示最优解 $g[i][j]$ 最优解的方案个数")]),a._v(" "),s("h4",{attrs:{id:"求次优解，第-k-优解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#求次优解，第-k-优解"}},[a._v("#")]),a._v(" 求次优解，第 k 优解")]),a._v(" "),s("p",[a._v("将每个状态表示成有序队列，将状态转移方程中的 $\\max\\quad\\min$ 转化成有序队列的合并\n01背包中，要求第 $k$ 优解，$dp[i][j]$ 是一个大小为 $k$ 的队列，$dp[i][j][1\\cdots k]$ 表示前 $i$ 个物品中，背包大小为 $j$ 时，第 $k$ 优解的值，\n长度为 $k$ 的队列 $dp[i][j]$ 由队列 $dp[i-1][j]$ 和队列 $dp[i-1][j-c[i]]+w[i]$ 合并")]),a._v(" "),s("h2",{attrs:{id:"树形dp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#树形dp"}},[a._v("#")]),a._v(" 树形DP")]),a._v(" "),s("ol",[s("li",[a._v("树形dp为在树的数据结构上dp")]),a._v(" "),s("li",[a._v("因为树形dp节点 $i$ 由其子节点推导而来，所以多用 后序遍历 + 记忆化")])]),a._v(" "),s("h2",{attrs:{id:"状态压缩dp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态压缩dp"}},[a._v("#")]),a._v(" 状态压缩dp")]),a._v(" "),s("ol",[s("li",[a._v("状压dp就是利用数的二进制位 0 或 1 表示状态")])]),a._v(" "),s("h2",{attrs:{id:"dp优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dp优化"}},[a._v("#")]),a._v(" DP优化")]),a._v(" "),s("h3",{attrs:{id:"滚动数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#滚动数组"}},[a._v("#")]),a._v(" 滚动数组")]),a._v(" "),s("ol",[s("li",[a._v("通过逆序最后一个维度，可以节约一维空间")])]),a._v(" "),s("h3",{attrs:{id:"单调队列-单调栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单调队列-单调栈"}},[a._v("#")]),a._v(" 单调队列/单调栈")]),a._v(" "),s("h3",{attrs:{id:"斜率优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#斜率优化"}},[a._v("#")]),a._v(" 斜率优化")]),a._v(" "),s("h3",{attrs:{id:"四边形优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四边形优化"}},[a._v("#")]),a._v(" 四边形优化")]),a._v(" "),s("p",[a._v("$函数 w 满足四边形不等式：对任意 i\\leq i'\\leq j\\leq j' \\rightarrow w(i,j)+w(i',j')\\leq w(i',j)+w(i,j')$\n$函数 w 区间包含单调性：对任意 i\\leq i'\\leq j'\\leq j \\rightarrow w(i',j')\\leq w(i,j)$")]),a._v(" "),s("p",[a._v("$用 s[i][j] 表示dp[i][j] 取最优时，分割点的下标，s[i][j]\\leq s[i][j+1]\\leq s[i+1][j+1]$")]),a._v(" "),s("h3",{attrs:{id:"状态设计优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态设计优化"}},[a._v("#")]),a._v(" 状态设计优化")])])}),[],!1,null,null,null);t.default=v.exports}}]);