(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{360:function(e,t,r){e.exports=r.p+"assets/img/lsm.1d35d6e3.png"},361:function(e,t,r){e.exports=r.p+"assets/img/lsmmerge.d1f455d5.png"},362:function(e,t,r){e.exports=r.p+"assets/img/lsmsdu.4518c2e1.png"},415:function(e,t,r){"use strict";r.r(t);var i=r(25),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"the-log-structured-merge-tree"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#the-log-structured-merge-tree"}},[e._v("#")]),e._v(" The Log-Structured Merge-Tree")]),e._v(" "),i("h2",{attrs:{id:"idea"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#idea"}},[e._v("#")]),e._v(" Idea")]),e._v(" "),i("ol",[i("li",[e._v("Use high speed of sequental write of disk")])]),e._v(" "),i("h2",{attrs:{id:"component"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#component"}},[e._v("#")]),e._v(" Component")]),e._v(" "),i("p",[i("img",{attrs:{src:r(360),alt:"LSM component"}})]),e._v(" "),i("ol",[i("li",[e._v("$C_0$ stsys in memory all the time")]),e._v(" "),i("li",[e._v("$C_1$ in disk but some of frequence referral page in memory")])]),e._v(" "),i("h2",{attrs:{id:"insert"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#insert"}},[e._v("#")]),e._v(" Insert")]),e._v(" "),i("ol",[i("li",[e._v("Write insert operation to log in order to recovery in case")]),e._v(" "),i("li",[e._v("Insert new entry to $C_0$")]),e._v(" "),i("li",[e._v("When the size of $C_0$ larger than some threshold, merge to $C_1$")]),e._v(" "),i("li",[e._v("$C_1$ likes B-tree, but its full")])]),e._v(" "),i("h2",{attrs:{id:"merge"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#merge"}},[e._v("#")]),e._v(" Merge")]),e._v(" "),i("p",[i("img",{attrs:{src:r(361),alt:"LSM Merge"}})]),e._v(" "),i("ol",[i("li",[e._v("Read $C_1$ unmerged leaf node into emptying block in memory")]),e._v(" "),i("li",[e._v("Read $C_0$ from leaf node and merge it with emptying block")]),e._v(" "),i("li",[e._v("Write merge result into filling block, delete used node from $C_0$")]),e._v(" "),i("li",[e._v("Do step 2-3 until the filling block is full, append this block into disk's new position")])]),e._v(" "),i("p",[e._v("Notes")]),e._v(" "),i("ol",[i("li",[e._v("$C_0$ does not use all ettries to merege. It remains frequent visited entry")]),e._v(" "),i("li",[e._v("$C_1$'s old block can be used for recovery. New block is written on new position")]),e._v(" "),i("li",[e._v("Usually, there are some unfull filling block, which will be stored in memory for next merge")]),e._v(" "),i("li",[e._v("When set checkpoint, cached info will be written to disk")])]),e._v(" "),i("h2",{attrs:{id:"search-delete-and-update"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#search-delete-and-update"}},[e._v("#")]),e._v(" Search, delete and update")]),e._v(" "),i("p",[i("img",{attrs:{src:r(362),alt:"LSM SDU"}})]),e._v(" "),i("p",[e._v("Search")]),e._v(" "),i("ol",[i("li",[e._v("Search happens from $C_0$ to $C_k$")]),e._v(" "),i("li",[e._v("Latest T time visited entries are cached in $C_0$, kT time visited entries are cached in $C_k$. This method can reduce search time")])]),e._v(" "),i("p",[e._v("Delete")]),e._v(" "),i("ol",[i("li",[e._v("Delete operation is done by insert")]),e._v(" "),i("li",[e._v("Check if deleted entry exists in $C_0$, if not, write a kv, which value is entry which is needed to be deleted")]),e._v(" "),i("li",[e._v("During merge, delete entry which has the same value as the kv")])]),e._v(" "),i("p",[e._v("Update")]),e._v(" "),i("ol",[i("li",[e._v("Set the entry as delete")]),e._v(" "),i("li",[e._v("When merge out from $C_0$, write the new value in $C_0$")])])])}),[],!1,null,null,null);t.default=s.exports}}]);