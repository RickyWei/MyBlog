# 树

## 性质

## 树的遍历

### 先序遍历

```cpp
void PreOrder(Node* root) {
    cout << root->_val << " ";
    if (root->_left) PreOrder(root->_left);
    if (root->_right) PreOrder(root->_right);
}

void PreOrder(Node* root) {
    Node* p = root;
    stack<Node*> s;
    while (p || !s.empty()) {
        while (p) {
            cout << p->_val << " ";
            s.push(p);
            p = p->_left;
        }
        if (!s.empty()) {
            p = s.top();
            s.pop();
            p = p->_right;
        }
    }
}
```

### 中序遍历

```cpp
void InOrder(Node* root) {
    if (root->_left) InOrder(root->_left);
    cout << root->_val << " ";
    if (root->_right) InOrder(root->_right);
}

void InOrder(Node* root) {
    Node* p = root;
    stack<Node*> s;
    while (p || !s.empty()) {
        while (p) {
            s.push(p);
            p = p->_left;
        }
        if (!s.empty()) {
            p = s.top();
            s.pop();
            cout << p->_val << " ";
            p = p->_right;
        }
    }
}

```

### 后序遍历

```cpp
void PostOrder(Node* root) {
    if (root->_left) PostOrder(root->_left);
    if (root->_right) PostOrder(root->_right);
    cout << root->_val << " ";
}

void PostOrder(Node* root) {
    Node *p = nullptr, *pre = nullptr;
    stack<Node*> s;
    s.push(root);
    int i = 0;
    while (!s.empty()) {
        p = s.top();
        if ((!p->_left && !p->_right) || pre == p->_right ||
            (pre == p->_left && !p->_right)) {
            cout << p->_val << " ";
            s.pop();
            pre = p;
        } else {
            if (p->_right) s.push(p->_right);
            if (p->_left) s.push(p->_left);
        }
    }
}
```
