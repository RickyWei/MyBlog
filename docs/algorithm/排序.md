# 排序

## 复杂度及稳定性

1. 稳定性
   1. 如果$A_i==A_j \&\& i<j$，排序后$A_i$仍然在$A_j$前
   2. pron: 可在上一次的排序基础上再排序
2. 原址排序
   1. 不需要额外辅助空间

```cpp
void BubbleSort(vector<int> &v) {
    bool flag = true;
    for (int i = 0; i < v.size() - 1 && flag; ++i) {
        flag = false;
        for (int j = 0; j < v.size() - 1 - i; ++j) {
            if (v[j] > v[j + 1]) {
                swap(v[j], v[j + 1]);
                flag = true;
            }
        }
    }
}
```


```cpp
void InsertSort(vector<int> &v) {
    for (int i = 1; i < v.size(); ++i) {
        int key = v[i], j;
        for (j = i; j > 0; --j) {
            if (v[j - 1] > key) {
                v[j] = v[j - 1];
            } else {
                break;
            }
        }
        v[j] = key;
    }
}
```

```cpp
void ShellSort(vector<int> &v) {
    for (int gap = v.size() / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < v.size(); ++i) {
            for (int j = i - gap; j >= 0 && v[j] > v[j + gap]; j -= gap) {
                swap(v[j], v[j + gap]);
            }
        }
    }
}
```

```cpp
void SelectSort(vector<int> &v) {
    for (int i = 0; i < v.size() - 1; ++i) {
        int pos = i;
        for (int j = i + 1; j < v.size(); ++j) {
            if (v[j] < v[pos]) pos = j;
        }
        swap(v[i], v[pos]);
    }
}
```

```cpp
void MergeSort(vector<int> &v, int l, int r) {
    int m = (l + r + 1) >> 1;
    if (l + 1 < r) {
        MergeSort(v, l, m);
        MergeSort(v, m, r);
    }
    // Merge
    vector<int> tmp(v);
    int ll = l, mm = m, i = 0;
    while (i < r - l + 1) {
        if (ll >= m)
            tmp[i] = v[mm++];
        else if (mm >= r)
            tmp[i] = v[ll++];
        else {
            if (v[ll] < v[mm])
                tmp[i] = v[ll++];
            else
                tmp[i] = v[mm++];
        }
        ++i;
    }
    for (int i = l; i < r; ++i) v[i] = tmp[i];
}
```

```cpp
void HeapSort(vector<int> &v) {
    priority_queue<int> maxq(v.begin(), v.end());
    for (int i = v.size() - 1; i >= 0; --i) {
        v[i] = maxq.top();
        maxq.pop();
    }
}
```

```cpp
void QuickSort(vector<int> &v, int l, int r) {
    if (l >= r) return;
    int key = v[l], i = l, j = r - 1;
    while (i < j) {
        while (i < j && v[j] >= key) --j;
        while (i < j && v[i] <= key) ++i;
        if (i < j) swap(v[i++], v[j--]);
    }
    swap(v[l], v[i]);
    QuickSort(v, l, i);
    QuickSort(v, i + 1, r);
}
```
