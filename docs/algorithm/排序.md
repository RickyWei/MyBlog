# 排序

## 复杂度及稳定性

1. 稳定性
   1. 如果$A_i==A_j \quad\&\&\quad i<j$，排序后$A_i$仍然在$A_j$前
   2. pron: 可在上一次的排序基础上再排序
2. 原址排序
   1. 不需要额外辅助空间

|          | 平均                   | 最好         | 最坏         | 辅助空间             | 稳定性       |
| :------- | :--------------------- | :----------- | :----------- | :------------------- | :----------- |
| 冒泡排序 | $O(n^2)$               | $O(n)$       | $O(n^2)$     | $O(1)$               | $\checkmark$ |
| 插入排序 | $O(n^2)$               | $O(n^2)$     | $O(n^2)$     | $O(1)$               | $\checkmark$ |
| 希尔排序 | $O(n\lg(n)\sim O(n^2)$ | $O(n^(1.3))$ | $O(n^2)$     | $O(1)$               |              |
| 选择排序 | $O(n^2)$               | $O(n^2)$     | $O(n^2)$     | $O(1)$               | $\checkmark$ |
| 堆排序   | $O(n\lg(n))$           | $O(n\lg(n))$ | $O(n\lg(n))$ | $O(1)$               |              |
| 归并排序 | $O(n\lg(n))$           | $O(n\lg(n))$ | $O(n\lg(n))$ | $O(n)$               | $\checkmark$ |
| 快速排序 | $O(n\lg(n))$           | $O(n\lg(n))$ | $O(n\lg(n))$ | $O(n\lg(n)\sim O(n)$ |              |
| 计数排序 | $O(n+k)$               | $O(n+k)$     | $O(n+k)$     | $O(n+k)$             |              |

## 冒泡排序

```cpp
void BubbleSort(vector<int> &v) {
    bool flag = true;
    for (int i = 0; i < v.size() - 1 && flag; ++i) {
        flag = false;
        for (int j = 0; j < v.size() - 1 - i; ++j) {
            if (v[j] > v[j + 1]) {
                swap(v[j], v[j + 1]);
                flag = true;
            }
        }
    }
}
```

## 插入排序

```cpp
void InsertSort(vector<int> &v) {
    for (int i = 1; i < v.size(); ++i) {
        int key = v[i], j;
        for (j = i; j > 0; --j) {
            if (v[j - 1] > key) {
                v[j] = v[j - 1];
            } else {
                break;
            }
        }
        v[j] = key;
    }
}
```

## 希尔排序

```cpp
void ShellSort(vector<int> &v) {
    for (int gap = v.size() / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < v.size(); ++i) {
            for (int j = i - gap; j >= 0 && v[j] > v[j + gap]; j -= gap) {
                swap(v[j], v[j + gap]);
            }
        }
    }
}
```

## 选择排序

```cpp
void SelectSort(vector<int> &v) {
    for (int i = 0; i < v.size() - 1; ++i) {
        int pos = i;
        for (int j = i + 1; j < v.size(); ++j) {
            if (v[j] < v[pos]) pos = j;
        }
        swap(v[i], v[pos]);
    }
}
```

## 堆排序

```cpp
void HeapSort(vector<int> &v) {
    priority_queue<int> maxq(v.begin(), v.end());
    for (int i = v.size() - 1; i >= 0; --i) {
        v[i] = maxq.top();
        maxq.pop();
    }
}
```

## 归并排序

```cpp
void MergeSort(vector<int> &v, int l, int r) {
    int m = (l + r + 1) >> 1;
    if (l + 1 < r) {
        MergeSort(v, l, m);
        MergeSort(v, m, r);
    }
    // Merge
    vector<int> tmp(v);
    int ll = l, mm = m, i = 0;
    while (i < r - l + 1) {
        if (ll >= m)
            tmp[i] = v[mm++];
        else if (mm >= r)
            tmp[i] = v[ll++];
        else {
            if (v[ll] < v[mm])
                tmp[i] = v[ll++];
            else
                tmp[i] = v[mm++];
        }
        ++i;
    }
    for (int i = l; i < r; ++i) v[i] = tmp[i];
}
```

## 快速排序

```cpp
void QuickSort(vector<int> &v, int l, int r) {
    if (l >= r) return;
    int key = v[l], i = l, j = r - 1;
    while (i < j) {
        while (i < j && v[j] >= key) --j;
        while (i < j && v[i] <= key) ++i;
        if (i < j) swap(v[i++], v[j--]);
    }
    swap(v[l], v[i]);
    QuickSort(v, l, i);
    QuickSort(v, i + 1, r);
}
```

## 计数排序

```cpp
void CountSort(vector<int> &v, int k) {
    vector<int> count(k, 0);
    for (int i = 0; i < v.size(); ++i) {
        count[v[i]] += 1;  // count[v[i]]=how many numbers of v[i]
    }
    for (int i = 1; i < k; ++i) {
        count[i] += count[i - 1];  // count[i]=number of elements <= i
    }
    vector<int> tmp = v;
    for (int i = tmp.size() - 1; i >= 0; --i) {
        v[count[tmp[i]]] = tmp[i];
        count[tmp[i]] -= 1;
    }
}
```
