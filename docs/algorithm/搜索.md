# 搜索

## 二分查找

1. 二分查找需要所查集合已经排序

```cpp
bool BinarySearch(vector<int> v, int target) {
    int l = 0, r = v.size() - 1, m;
    while (l < r) {
        m = (l + r) / 2;
        if (v[m] < target)
            l = m + 1;
        else
            r = m;
    }
    return v[l] == target;
}

// STL
//Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.
template <class ForwardIterator, class T>
ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
                            const T &val);
```

## DFS

```cpp
bool DFS(vector<vector<int>> &v, vector<vector<bool>> &visited, int i, int j,
         int target) {
    if (v[i][j] == target) return true;
    bool ret = false;
    if (i - 1 >= 0 && !visited[i - 1][j])
        visited[i - 1][j] = true, ret |= DFS(v, visited, i - 1, j, target);
    if (i + 1 < v.size() && !visited[i + 1][j])
        visited[i + 1][j] = true, ret |= DFS(v, visited, i + 1, j, target);
    if (j - 1 >= 0 && !visited[i][j - 1])
        visited[i][j - 1] = true, ret |= DFS(v, visited, i, j - 1, target);
    if (j + 1 < v[0].size() && !visited[i][j + 1])
        visited[i][j + 1] = true, ret |= DFS(v, visited, i, j + 1, target);
    return ret;
}


bool DFS(vector<vector<int>> &v, int target) {
    vector<vector<bool>> visited(v.size(), vector<bool>(v[0].size(), false));
    stack<vector<int>> s;
    s.push({0, 0});
    while (!s.empty()) {
        vector<int> p = s.top();
        s.pop();
        int i = p[0], j = p[1];
        if (v[i][j] == target) return true;
        if (i - 1 >= 0 && !visited[i - 1][j])
            visited[i - 1][j] = true, s.push({i - 1, j});
        if (i + 1 < v.size() && !visited[i + 1][j])
            visited[i + 1][j] = true, s.push({i + 1, j});
        if (j - 1 >= 0 && !visited[i][j - 1])
            visited[i][j - 1] = true, s.push({i, j - 1});
        if (j + 1 >= 0 && !visited[i][j + 1])
            visited[i][j + 1] = true, s.push({i, j + 1});
    }
    return false;
}
```

## BFS

```cpp
bool BFS(vector<vector<int>> &v, int target) {
    vector<vector<bool>> visited(v.size(), vector<bool>(v[0].size(), false));
    queue<vector<int>> q;
    q.push({0, 0});
    while (!q.empty()) {
        vector<int> p = q.front();
        q.pop();
        int i = p[0], j = p[1];
        if (v[i][j] == target) return true;
        if (i - 1 >= 0 && !visited[i - 1][j])
            visited[i - 1][j] = true, q.push({i - 1, j});
        if (i + 1 < v.size() && !visited[i + 1][j])
            visited[i + 1][j] = true, q.push({i + 1, j});
        if (j - 1 >= 0 && !visited[i][j - 1])
            visited[i][j - 1] = true, q.push({i, j - 1});
        if (j + 1 >= 0 && !visited[i][j + 1])
            visited[i][j + 1] = true, q.push({i, j + 1});
    }
    return false;
}
```

## 回溯

1. 回溯是一种暴力枚举
2. 注意递归边界
   1. 何时终止
   2. 每层的递归结果是否需要综合子递归的结果（或，且）
