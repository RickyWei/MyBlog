# 堆

## 性质

1. 父节点永远小于两个子节点

## 插入

1. 将新元素插入末尾
2. 从该元素向上迭代，维护堆的性质

## 删除

1. 只能删除堆顶
2. 用最后一个元素代替堆顶，向下迭代我，维护堆性质

## 代码

```cpp
template <typename T>
class MinHeap {
   public:
    void push(T val);
    T top();
    void pop();

   private:
    vector<T> v;
};

template <typename T>
void MinHeap<T>::push(T val) {
    v.push_back(val);
    int idx = v.size() - 1;
    int idxp = (idx - 1) >> 1;
    while (idx > 0 && v[idx] < v[idxp]) {
        swap(v[idx], v[idxp]);
        idx = idxp;
    }
}

template <typename T>
T MinHeap<T>::top() {
    return v.front();
}

template <typename T>
void MinHeap<T>::pop() {
    if (v.size() == 0) return;
    swap(v[0], v[v.size() - 1]);
    v.pop_back();
    int idx = 0, idxl = 1, idxr = 2;
    while (idx < v.size()) {
        idxl = idx * 2 + 1, idxr = idx * 2 + 2;
        if (idxl >= v.size()) break;
        if (idxr < v.size()) {
            if (v[idxl] < v[idxr]) {
                if (v[idxl] < v[idx]) {
                    swap(v[idxl], v[idx]);
                    idx = idxl;
                } else
                    break;
            } else {
                if (v[idxr] < v[idx]) {
                    swap(v[idxr], v[idx]);
                    idx = idxr;
                } else
                    break;
            }
        } else {
            if (v[idxl] < v[idx]) {
                swap(v[idx], v[idxl]);
                idx = idxl;
            } else
                break;
        }
    }
}
```
