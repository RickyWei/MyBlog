# 动态规划

## 性质

::: tip
动态规划本质还是一种枚举
:::

1. 最优子结构：全局最优解包含局部最优解
2. 重叠子问题：递归算法反复求解相同的子问题
3. 无后性：即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响

## 初始化

1. dp数组大小：
   1. $维度 = 数据维度 + 隐含维度（与限制条件有关 || ）$
   2. 根据状态范围确定，$n+1$通常为了方便计算（返回 $dp[n]$）
2. 值：
   1. 单个点，相邻点
   2. 边界线，对角线

## 状态转移

### 转移方程

1. 先思考使用回溯的罗杰
2. 确定下标代表的状态含义

### 记忆化搜索

1. 递归时使用空间记录中间子问题结果
2. 需要区分未计算和其他特殊值（无解）

### 递推

1. 是递归的逆序，从子问题开始求解
2. 循环顺序取决于，按何种顺序是求解小问题（范围）->大问题（范围）

## 线性DP

$dp[i]=max\{dp[i-1]+cost[i]\}$

## 区间DP

$dp[i][j]=max\{dp[i][k]+dp[k+1][j]+cost[i][j]\}$

## 背包模型

### 01背包

有 $n$ 件物品，放入最大容量 $v$ 的背包，第 $i$ 件物品体积（费用）$c[i]$ 价值$w[i]$，求最大价值

$dp[i][j]=max\{dp[i-1][j],dp[i][j-c[i]]+w[i]]\}\qquad (c=cost, w=weight)$

### 完全背包

每种物品个数不限

$dp[i][j]=max\{dp[i][j-k*c[i]]+k*w[i]]\}$

### 多重背包

第 $i$ 种物品有 $M_i$ 个

$dp[i][j]=max\{dp[i][j-k*c[i]]+k*w[i]]\}$

### 二维费用背包

每件物品有两种费用

$dp[i][j][k]=max\{dp[i-1][j][k],dp[i][j-c_1[i]][k-c_2[i]]+w[i]\}$

### 分组背包

物品被划分为 $k$ 组，每组中的物品相互冲突只能选一件

$dp[i][j]=max\{dp[i-1][j],dp[i-1][j-c[k]]+w[k]\} \qquad \text{k in group i}$

### 有依赖背包

物品 $i$ 依赖于物品 $j$，即选 $i$ 必须选 $j$

### 泛化物品

泛化物品是一个定义域为 $0\cdots v$ 的函数 $f$，当分配给费用 $j$ 时，价值为$f(j)$

### 背包问法变化

#### 输出方案

记录下每个状态的最优解由状态转移方程的哪一项推出
01背包中，可用 $g[[i][j]=0$ 表示$dp[i][j]=dp[i-1][j]$ ， $g[i][j]=1$ 表示 $dp[i][j]=dp[i-1][j-c[i]]+w[i]$

#### 输出字典序最小最优方案

可先把物品编号做 $x\leftarrow N+1-x$ 的转换，在输出方案时转换回来，编号变换后可按之前的转移方程求值，
输出方案时，如果 $dp[i-1][j]$ 和 $dp[i-1][j-c[i]]+w[i]$ 都成立，按照后者输出，即选择了物品 $i$ 输出其原来的编号 $N-1-i$

#### 方案总数

如求装满背包时方案的总数
在初始化时 $dp[0][0]=0\qquad dp[0][1\cdots v]$，将 $\max$ 改为 $sum$

#### 最优方案总数

$dp[i][j]$ 表示最优解 $g[i][j]$ 最优解的方案个数

#### 求次优解，第 k 优解

将每个状态表示成有序队列，将状态转移方程中的 $\max\quad\min$ 转化成有序队列的合并
01背包中，要求第 $k$ 优解，$dp[i][j]$ 是一个大小为 $k$ 的队列，$dp[i][j][1\cdots k]$ 表示前 $i$ 个物品中，背包大小为 $j$ 时，第 $k$ 优解的值，
长度为 $k$ 的队列 $dp[i][j]$ 由队列 $dp[i-1][j]$ 和队列 $dp[i-1][j-c[i]]+w[i]$ 合并

## 树形DP

1. 树形dp为在树的数据结构上dp
2. 因为树形dp节点 $i$ 由其子节点推导而来，所以多用 后序遍历 + 记忆化

## 状态压缩dp

1. 状压dp就是利用数的二进制位 0 或 1 表示状态

## DP优化

### 滚动数组

1. 通过逆序最后一个维度，可以节约一维空间

### 单调队列/单调栈

### 斜率优化

### 四边形优化

$函数 w 满足四边形不等式：对任意 i\leq i'\leq j\leq j' \rightarrow w(i,j)+w(i',j')\leq w(i',j)+w(i,j')$
$函数 w 区间包含单调性：对任意 i\leq i'\leq j'\leq j \rightarrow w(i',j')\leq w(i,j)$

$用 s[i][j] 表示dp[i][j] 取最优时，分割点的下标，s[i][j]\leq s[i][j+1]\leq s[i+1][j+1]$

### 状态设计优化
