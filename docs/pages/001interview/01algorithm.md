# Algorithm

## 树的遍历



## Top K 问题

1. 快排的partition
   1. 划分后可得到pivot的位置，再根据此时需要数的个数继续划分，直到k==0
2. 堆
   1. 若求最大top k，维持一个最小堆，当堆满时将顶部元素和新数比较，若新数较大则移除对顶插入
   2. 求最小top k，维持最大堆

## 海量数据问题

1. bloom filter
   1. bloom filter使用一个m bit保存信息，初始全为0
   2. 使用n个hash函数，一个值通过n个hash后将对应位设置为1
   3. 查找值存在时，查看n个hash对应的位是否都为1，有重合的问题
2. hash
   1. 将大文件的内容经过hash分割未小文件，这样每个小文件的内容相同
   2. 若分割后的文件依旧超出内存，则可再次hash
3. bit map
   1. 用 1 bit 标记该值是否存在
   2. 用 2 bit 标记值是01否00存在，是否重复10
4. heap