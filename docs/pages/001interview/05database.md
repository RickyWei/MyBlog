# Database

## 事务特性

1. Atomicity
2. Consistent
3. Isolate
4. Durable

## 脏读，不可重复读，幻读

1. 脏读，A事务还没提交时B事务读取，之后A回滚，B读到脏数据
2. 不可重复读，A事务中会读某个数据多次，B事务在期间修改了数据，A两次读到同一个数据不一致
3. 幻读，A事务修改表中全部数据时，B事务添加了一条数据，A之后发现表中还有未修改数据

## 隔离级别

1. 读未提交
2. 读已提交，解决脏读
3. 可重复读，解决不可重复读
4. 串行化，解决幻读

## 乐观锁和悲观锁

1. 乐观锁，每次取数据时认为别人都不会修改，所以不上锁，当提交更新时会判断期间数据有无被他人修改
   1. 数据版本，为表增加一个version字段，当读数据时将version字段值一同读出，每次更新数据version+1，当提交时比对version是否过期
   2. 时间戳，添加timestamp字段类型，其他同上
2. 悲观锁，每次修改数据时都获得锁

## mysql的引擎

1. INNODB
2. MYISAM
3. ISAM
4. HEAP

## 聚族索引和非聚族索引

1. ![index](./imgdb/index.png)
2. 聚族索引
   1. 数据和索引放在一起
   2. 一个表仅有一个聚族索引，默认为主键，未定义主键时innodb选择一个唯一的非空索引代替，若没有innodb隐式定义一个主键
3. 非聚族索引
   1. 数据和索引分离

## 索引的实现

1. B树 / B+树
   1. B树每个节点可以有多个子树，这样一个节点的内容多，树的层数低，有利于磁盘IO（磁盘每次IO会预读，一次可取到一个节点的内容，减少IO次数）
   2. B+树节点只有索引，层数更低，且每次查询都会落到叶子节点，查询稳定
   3. B+树叶子节点有指向右边兄弟的指针，且最后一层数据按索引排列，这样找到起始节点就可以一直向后读到范围结束
2. hash
   1. hash索引查找 O(1)
   2. hash索引只能用来 = IN <= >=，不能用来范围查询

## mysql模糊查询

1. SELECT 字段 FROM 表 WHERE 某字段 Like 条件
   1. % 匹配任意个字符
   2. _ 匹配单个字符
2. SELECT 字段 FROM 表 WHERE 某字段 REGEXP 正则表达式

## 模糊查询与索引

1. like %keyword 索引失效
   1. 因为任何字符可以匹配 % 无法查找
   2. `select * from xxx where mobile_reverse like reverse('%5678');` mobile_reverse存储mobile的倒叙文本
2. like keyword% 索引有效
3. like %keyword% 索引失效，也无法反向索引

## redis缓存穿透，缓存击穿和缓存雪崩

1. 缓存穿透
   1. 访问不存在的key，每次请求落在数据库，高并发时挂掉
2. 缓存击穿
   1. 大量数据访问同一个key（如秒杀），缓存过期的瞬间大量请求落在数据库
3. 缓存雪崩
   1. 大量key同时过期
   2. 解决：随机key的过期时间；热点数据考虑不失效